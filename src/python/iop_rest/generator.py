import prance
from typing import TextIO
from pathlib import Path
import datamodel_code_generator
from datamodel_code_generator import DataModelType, PythonVersion
from datetime import datetime
import re

_TYPES = {
    'string': 'str',
    'number': 'float',
    'integer': 'int',
    'boolean': 'bool',
    'array': 'list',
    'object': 'any'
}

class PythonWriter:
    file: TextIO
    scope: int = 0
    indent: int = 4

    def __init__(self, file: TextIO, indent = 4) -> None:
        self.file = file
        self.indent = indent

    def write(self, line = "", scope = 0):
        if line == "":
            self.file.write("\n")
        else:
            self.file.write(f'{" " * self.indent * self.scope}{line}\n')
        self.scope += scope
    
    def writelines(self, lines: list[str], scope = 0):
        for line in lines:
            self.write(line)
        self.scope += scope


# Unused, replaced by datamodel-code-generator
class DataclassGenerator:
    writer: PythonWriter
    _registered = {}

    def __init__(self, writer: PythonWriter) -> None:
        self.writer = writer

    def resolve_type(self, prop: dict[str, any]) -> str:
        if not 'type' in prop:
            return 'any'
        if prop['type'] == 'object':
            try:
                return list(self._registered.keys())[list(self._registered.values()).index(prop)]
            except:
                return 'any'
        elif prop['type'] == 'array' and 'items' in prop:
            if 'items' in prop:
                return f"{_TYPES[prop['type']]}[{self.resolve_type(prop['items'])}]"
        else:
            return _TYPES[prop['type']]

    def find_unregistered_classes(self, props: dict[str, any]) -> dict[str, any]:
        return {k: v for k, v in props.items() if 'type' in v and v['type'] == 'object' and not v in self._registered.values()}

    def generate(self, name: str, spec: dict[str, any]):
        classname = name.rsplit('.', 1)[-1]
        self._registered[name] = spec
        self.writer.writelines([
            "@dataclass(init=False)",
            f"class {classname}(BaseModel, Message):"
        ], scope=1)
        if 'description' in spec:
            self.writer.writelines([
                '"""',
                *str(spec['description']).splitlines(),
                '"""'
            ])
        objs = self.find_unregistered_classes(spec['properties'])
        for key, obj in objs.items():
            self.writer.write()
            self.generate(f'{name}.{key}', obj)
        for key, prop in spec['properties'].items():
            _type = self.resolve_type(prop)
            if not ('required' in spec and key in spec['required']):
                _type = f'Optional[{_type}]'
            self.writer.write(f"{key}: {_type}")
        self.writer.write(scope=-1)


class ClientGenerator:
    writer: PythonWriter

    def __init__(self, writer: PythonWriter) -> None:
        self.writer = writer

    @staticmethod
    def camel_to_snake(s: str):
        return ''.join(['_'+c.lower() if c.isupper() else c for c in s]).lstrip('_')
    
    @staticmethod
    def normalize_symbol(s: str):
        return ClientGenerator.camel_to_snake(f"{''.join([l for l in s if str.isalnum(l) or l == '_'])}")
    
    def resolve_type(self, prop: dict[str, any]) -> str:
        if '$ref' in prop:
            return re.sub(r".*\/components\/schemas\/", "", prop['$ref']).replace('/', '.')
        if not 'type' in prop:
            return ''
        if prop['type'] == 'object':
            return 'dict'
        elif prop['type'] == 'array' and 'items' in prop:
            if 'items' in prop:
                return f"{_TYPES[prop['type']]}[{self.resolve_type(prop['items'])}]"
        return _TYPES[prop['type']]

    def write_header(self):
        self.writer.writelines([
            "# generated by REST Client Framework for IOP:",
            f"#   timestamp: {datetime.now().isoformat()}",
            "",
        ])

    def write_imports(self):
        self.writer.writelines([
            "from iop_rest.api import BaseClientREST",
            "from uplink.arguments import *",
            "from uplink.commands import *",
            "from uplink.decorators import *",
            "from uplink import returns",
            "from .models import *",
            "",
        ])

    def generate_args(self, definition: dict[str, any]) -> str:
        args = [("self", None)]
        if 'parameters' in definition:
            for param in definition['parameters']:
                _type = self.resolve_type(param['schema'])
                symbol = self.normalize_symbol(param['name'])
                args.append(
                    (symbol, {
                        'query': 'Query',
                        'path': 'Path',
                        'header': 'Header',
                    }[param['in']] + f"(\"{param['name']}\", type={_type})")
                )
        if 'requestBody' in definition:
            try:
                _type = self.resolve_type(definition['requestBody']['content']['application/json']['schema'])
            except:
                _type = "str"
            args.append(('body', f'Body(type={_type})'))
        return ', '.join([f"{k}{(': ' + v) if v else ''}" for k,v in args])


    def generate_function(self, path: str, method: str, definition: dict[str, any]):
        if 'operationId' in definition:
            fname = self.camel_to_snake(definition['operationId'])
        else:
            fname = f"{method}_{''.join([l for l in '_'.join(path.split('/')) if str.isalnum(l) or l == '_'])}"
        try:
            return_type = self.resolve_type(definition['responses']['200']['content']['application/json']['schema'])
        except:
            return_type = ''
        self.writer.write("@json")
        self.writer.write(f"@{method}('{path.lstrip('/')}')")
        args = self.generate_args(definition)
        self.writer.write(f"def {fname}({args}){(' -> ' + return_type) if return_type else ''}:", scope=1)
        if 'summary' in definition:
            self.writer.writelines([
                '"""',
                *str(definition['summary']).splitlines(),
                '"""',
            ])
        self.writer.write("pass", scope=-1)
        self.writer.write()

    def generate(self, name: str, spec: dict[str, any]):
        self.write_header()
        self.write_imports()
        self.writer.write(f"@returns.json")
        self.writer.write(
            "@headers({"
        , scope=1)
        self.writer.writelines([
            '"Content-Type": "application/json",',
            '"Accept": "application/json",',
            '"Charset": "utf-8",',
        ], scope=-1)
        self.writer.write("})")
        self.writer.write(f"class {name}(BaseClientREST):", scope=1)
        if 'title' in spec['info']:
            self.writer.writelines([
                '"""',
                *str(spec['info']['title']).splitlines(),
                '"""',
            ])
        self.writer.write()
        for path, methods in spec['paths'].items():
            for method, definition in methods.items():
                self.generate_function(path, method, definition)
                


def generate_modules(name: str, input_path: Path, output_path: Path):
    parser = prance.BaseParser(input_path.as_posix())
    # generate dataclasses
    datamodel_code_generator.generate(
        input_path,
        output=output_path.joinpath("models.py"),
        reuse_model=True,
        use_schema_description=True,
        use_field_description=True,
        output_model_type=DataModelType.PydanticV2BaseModel,
        target_python_version=PythonVersion.PY_310,
        additional_imports=['iop.Message', 'dataclasses.dataclass'],
        use_standard_collections=True,
        custom_template_dir=Path(__file__).parent.joinpath('templates'),
        use_subclass_enum=True,
    )
    with open(output_path.joinpath('api.py'), 'w', encoding='utf-8') as file:
        client_generator = ClientGenerator(PythonWriter(file))
        client_generator.generate(name, parser.specification)
    with open(output_path.joinpath('__init__.py'), 'w') as file:
        pass


